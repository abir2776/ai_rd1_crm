import os
import time
import json
import uuid
from datetime import datetime, timezone
from typing import Dict, List, Optional

import requests
from celery import shared_task
from django.core.files.base import ContentFile
from django.core.files.storage import default_storage
from dotenv import load_dotenv
from openai import OpenAI

from cv_formatter.models import CVFormatterConfig, FormattedCV
from organizations.models import Organization
from subscription.models import Subscription

load_dotenv()

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
PDF_FOLDER = "formatted_pdfs"

# Ensure folders exist
os.makedirs(PDF_FOLDER, exist_ok=True)
os.makedirs("resume_candidates", exist_ok=True)


# Function tool definition
GET_CV_RETURN_TOOL = {
    "type": "function",
    "function": {
        "name": "get_cv_return",
        "description": (
            "You will return the formatted CV information to the user. "
            "You will execute this function to return the formatted CV information to the user. "
            "Now there are some instructions for you for some fields. "
            "The field professional_summary will be generated by you, you will generate by checking the CV "
            "and summarize the professional summary. "
            "The field skills will be generated by you, you will generate by checking the CV and summarize the skills. "
            "The field areas_of_expertise will be generated by you, you will generate by checking the CV and summarize the areas of expertise. "
            "The field areas_for_improvement will be generated by you, you will generate by checking the CV and summarize the areas for improvement."
        ),
        "parameters": {
            "type": "object",
            "strict": False,
            "required": [
                "full_name",
                "email_address",
                "phone_number",
                "address",
                "professional_summary",
                "professional_experience",
                "education",
                "skills",
                "certifications",
                "languages",
                "areas_of_expertise",
                "areas_for_improvement",
            ],
            "properties": {
                "full_name": {"type": ["string", "null"]},
                "email_address": {"type": ["string", "null"]},
                "phone_number": {"type": ["string", "null"]},
                "address": {"type": ["string", "null"]},
                "professional_summary": {"type": ["string", "null"]},
                "professional_experience": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": [
                            "job_title",
                            "company_name",
                            "start_date",
                            "end_date",
                            "position",
                            "job_description",
                        ],
                        "properties": {
                            "job_title": {"type": ["string", "null"]},
                            "company_name": {"type": ["string", "null"]},
                            "start_date": {"type": ["string", "null"]},
                            "end_date": {"type": ["string", "null"]},
                            "position": {"type": ["string", "null"]},
                            "job_description": {
                                "type": "array",
                                "items": {"type": "string"},
                            },
                        },
                    },
                },
                "education": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": [
                            "degree",
                            "major",
                            "school_name",
                            "start_date",
                            "end_date",
                        ],
                        "properties": {
                            "degree": {"type": ["string", "null"]},
                            "major": {"type": ["string", "null"]},
                            "school_name": {"type": ["string", "null"]},
                            "start_date": {"type": ["string", "null"]},
                            "end_date": {"type": ["string", "null"]},
                        },
                    },
                },
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["skill_name", "skill_description"],
                        "properties": {
                            "skill_name": {"type": ["string", "null"]},
                            "skill_description": {"type": ["string", "null"]},
                        },
                    },
                },
                "certifications": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": [
                            "certification_name",
                            "certification_authority",
                            "start_date",
                            "end_date",
                        ],
                        "properties": {
                            "certification_name": {"type": ["string", "null"]},
                            "certification_authority": {"type": ["string", "null"]},
                            "start_date": {
                                "type": ["string", "null"],
                                "format": "date",
                            },
                            "end_date": {"type": ["string", "null"], "format": "date"},
                        },
                    },
                },
                "languages": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["language_name", "proficiency"],
                        "properties": {
                            "language_name": {"type": ["string", "null"]},
                            "proficiency": {"type": ["string", "null"]},
                        },
                    },
                },
                "areas_of_expertise": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["expertise_name", "expertise_description"],
                        "properties": {
                            "expertise_name": {"type": ["string", "null"]},
                            "expertise_description": {"type": ["string", "null"]},
                        },
                    },
                },
                "areas_for_improvement": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["area_name", "area_description"],
                        "properties": {
                            "area_name": {"type": ["string", "null"]},
                            "area_description": {"type": ["string", "null"]},
                        },
                    },
                },
            },
        },
    },
}


def extract_text_from_pdf(file_path: str) -> Optional[str]:
    """
    Extract text from PDF using multiple fallback methods.
    """
    try:
        import fitz  # PyMuPDF

        doc = fitz.open(file_path)
        text = []
        for page in doc:
            text.append(page.get_text("text"))
        if text and "".join(text).strip():
            return "\n".join(text)
    except Exception as e:
        print(f"PyMuPDF failed: {e}")

    try:
        import pdfplumber

        with pdfplumber.open(file_path) as pdf:
            pages_text = [p.extract_text() or "" for p in pdf.pages]
        if any(pages_text):
            return "\n".join(pages_text)
    except Exception as e:
        print(f"pdfplumber failed: {e}")

    try:
        from pypdf import PdfReader

        reader = PdfReader(file_path)
        all_text = "\n".join(page.extract_text() or "" for page in reader.pages)
        return all_text.strip()
    except Exception as e:
        print(f"pypdf failed: {e}")

    try:
        from pdf2image import convert_from_path
        import pytesseract

        pages = convert_from_path(file_path, dpi=300)
        full_text = "\n".join(pytesseract.image_to_string(img) for img in pages)
        return full_text.strip()
    except Exception as e:
        print(f"OCR failed: {e}")

    return None


def extract_cv_data_with_openai(
    cv_text: str, sections: List[str] = None
) -> Optional[Dict]:
    """
    Extract CV data using OpenAI Chat Completions API with function calling.
    """
    try:
        client = OpenAI(api_key=OPENAI_API_KEY)

        prompt = f"""You are a professional CV parser and career advisor. Carefully read and analyze the following CV/resume text.

CV TEXT:
{cv_text}

CRITICAL INSTRUCTIONS - YOU MUST FOLLOW THESE:

1. MANDATORY FIELDS - These MUST be generated even if not explicitly stated in the CV:
   
   a) professional_summary: 
      - Write a compelling 3-4 sentence summary of the candidate's professional profile
      - Highlight their key strengths, experience level, and career focus
      - This field is MANDATORY and cannot be empty
   
   b) skills: 
      - Extract ALL skills mentioned or implied in the CV
      - Add meaningful descriptions for each skill
      - Include technical skills, soft skills, and domain expertise
      - This field is MANDATORY and must contain at least 3-5 skills
   
   c) areas_of_expertise: 
      - Identify 3-5 key areas where the candidate demonstrates expertise
      - Base this on their experience, achievements, and responsibilities
      - Each expertise should have a detailed description
      - This field is MANDATORY and cannot be empty
   
   d) areas_for_improvement (recommendations): 
      - Suggest 3-5 constructive areas for professional development
      - Focus on skills that would enhance their career progression
      - Consider industry trends and common career advancement paths
      - Examples: "Cloud computing certifications", "Leadership training", "Advanced data analytics"
      - This field is MANDATORY and cannot be empty

2. PROFESSIONAL EXPERIENCE - CRITICAL:
   - For job_title: Extract the EXACT position title (e.g., "Senior Software Engineer", "Marketing Manager")
   - If job title is unclear, infer it from the job description
   - For position: Use the same as job_title or a variant
   - NEVER leave job_title or position empty
   - If multiple job titles exist in one role, use the most senior/recent one

3. DATA EXTRACTION RULES:
   - Extract all information accurately from the CV
   - For dates: Use format "YYYY-MM" or "Month YYYY" (e.g., "2020-01" or "January 2020")
   - For current positions: Use "Present" as end_date
   - If information is missing, infer it intelligently from context
   - ONLY return null for fields that truly have no information available

4. QUALITY STANDARDS:
   - professional_summary: Minimum 50 words
   - skills: Minimum 3 items with descriptions
   - areas_of_expertise: Minimum 3 items with descriptions  
   - areas_for_improvement: Minimum 3 items with descriptions
   - Each job_description: Minimum 2 bullet points

5. If this document is clearly not a professional CV/resume, return null for all fields.

Now extract all the CV data using the get_cv_return function. Remember: professional_summary, skills, areas_of_expertise, and areas_for_improvement MUST be generated with meaningful content."""

        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "system",
                    "content": """You are an expert CV parser and career advisor with 10+ years of experience. 
You excel at extracting structured data from resumes and providing insightful career recommendations.
You ALWAYS generate comprehensive professional summaries, skills lists, areas of expertise, and improvement recommendations.
You NEVER leave mandatory fields empty.""",
                },
                {"role": "user", "content": prompt},
            ],
            tools=[GET_CV_RETURN_TOOL],
            tool_choice={"type": "function", "function": {"name": "get_cv_return"}},
            temperature=0.5,  # Increased for better generation of recommendations
        )

        # Extract function call result
        message = response.choices[0].message

        if message.tool_calls:
            tool_call = message.tool_calls[0]
            if tool_call.function.name == "get_cv_return":
                result = json.loads(tool_call.function.arguments)

                # Validate that we got actual data
                if not result.get("full_name"):
                    print("No valid CV data extracted - no name found")
                    return None

                # Enhanced validation for mandatory generated fields
                if not result.get("professional_summary"):
                    print("WARNING: No professional summary generated")
                    result["professional_summary"] = (
                        "Professional with experience in the field."
                    )

                if not result.get("skills") or len(result.get("skills", [])) == 0:
                    print("WARNING: No skills generated")
                    result["skills"] = [
                        {
                            "skill_name": "Professional Skills",
                            "skill_description": "Various professional competencies demonstrated through work experience",
                        }
                    ]

                if (
                    not result.get("areas_of_expertise")
                    or len(result.get("areas_of_expertise", [])) == 0
                ):
                    print("WARNING: No areas of expertise generated")
                    result["areas_of_expertise"] = [
                        {
                            "expertise_name": "Core Competency",
                            "expertise_description": "Primary area of professional expertise",
                        }
                    ]

                if (
                    not result.get("areas_for_improvement")
                    or len(result.get("areas_for_improvement", [])) == 0
                ):
                    print(
                        "WARNING: No areas for improvement generated - adding defaults"
                    )
                    result["areas_for_improvement"] = [
                        {
                            "area_name": "Continuous Learning",
                            "area_description": "Stay updated with latest industry trends and technologies",
                        },
                        {
                            "area_name": "Professional Certifications",
                            "area_description": "Consider obtaining relevant industry certifications to enhance credentials",
                        },
                        {
                            "area_name": "Leadership Development",
                            "area_description": "Develop leadership and management skills for career advancement",
                        },
                    ]

                # Validate professional experience job titles
                if result.get("professional_experience"):
                    for idx, exp in enumerate(result["professional_experience"]):
                        if not exp.get("job_title") or exp.get("job_title") == "null":
                            print(f"WARNING: Missing job title in experience {idx}")
                            # Try to infer from position or use generic
                            exp["job_title"] = (
                                exp.get("position") or "Professional Role"
                            )

                        if not exp.get("position") or exp.get("position") == "null":
                            exp["position"] = (
                                exp.get("job_title") or "Professional Role"
                            )

                        # Ensure job description has content
                        if (
                            not exp.get("job_description")
                            or len(exp.get("job_description", [])) == 0
                        ):
                            exp["job_description"] = [
                                "Performed various professional duties and responsibilities"
                            ]

                # Map the fields to match your template expectations
                mapped_result = {
                    "full_name": result.get("full_name"),
                    "email": result.get("email_address"),
                    "phone": result.get("phone_number"),
                    "address": result.get("address"),
                    "professional_summary": result.get("professional_summary"),
                    "professional_experience": result.get(
                        "professional_experience", []
                    ),
                    "education": result.get("education", []),
                    "skills": result.get("skills", []),
                    "certifications": result.get("certifications", []),
                    "languages": result.get("languages", []),
                    "areas_of_expertise": result.get("areas_of_expertise", []),
                    "recommendations": result.get(
                        "areas_for_improvement", []
                    ),  # Mapped to recommendations
                    "areas_for_improvement": result.get(
                        "areas_for_improvement", []
                    ),  # Also keep original
                }

                # Final validation log
                print(f"Extracted CV data summary:")
                print(f"  - Name: {mapped_result['full_name']}")
                print(
                    f"  - Professional Summary: {len(mapped_result.get('professional_summary', ''))} chars"
                )
                print(f"  - Skills: {len(mapped_result.get('skills', []))} items")
                print(
                    f"  - Areas of Expertise: {len(mapped_result.get('areas_of_expertise', []))} items"
                )
                print(
                    f"  - Recommendations: {len(mapped_result.get('recommendations', []))} items"
                )
                print(
                    f"  - Experience entries: {len(mapped_result.get('professional_experience', []))}"
                )

                return mapped_result

        print("No function call in response")
        return None

    except Exception as e:
        print(f"Error extracting CV data: {e}")
        import traceback

        traceback.print_exc()
        return None


def render_cv_to_html(cv_data: Dict, with_logo: bool = True) -> str:
    """
    Render CV data to HTML using Jinja2 template.
    """
    from jinja2 import Environment, FileSystemLoader
    from django.conf import settings

    # Use absolute path from Django settings
    template_dir = os.path.join(settings.BASE_DIR, "cv_formatter/templates")

    env = Environment(loader=FileSystemLoader(template_dir))

    if with_logo:
        template = env.get_template("cv_templates/cv_template.html")
    else:
        template = env.get_template("cv_templates/sec_cv_template.html")

    return template.render(cv_data=cv_data)


def convert_html_to_pdf(html_content: str, output_path: str) -> bool:
    """
    Convert HTML to PDF using WeasyPrint.
    """
    try:
        from weasyprint import HTML, CSS

        custom_css = """
        @page {
            margin: 0;
        }
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
        }
        .cv-container {
            margin: 0;
            padding: 0 40px 40px 40px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        """

        HTML(string=html_content).write_pdf(
            output_path, stylesheets=[CSS(string=custom_css)]
        )
        return True
    except Exception as e:
        print(f"Error converting HTML to PDF: {e}")
        return False


def upload_cv_to_platform(
    candidate_id: int, file_path: str, config: "CVFormatterConfig"
) -> bool:
    """
    Upload formatted CV to the recruitment platform.
    """
    try:
        access_token = config.platform.access_token

        with open(file_path, "rb") as file:
            response = requests.post(
                f"{config.platform.base_url}/candidates/{candidate_id}/attachments",
                headers={
                    "Authorization": f"Bearer {access_token}",
                },
                files={"file": file},
                timeout=30,
            )

        if response.status_code == 401:
            access_token = config.platform.refresh_access_token()
            if access_token:
                with open(file_path, "rb") as file:
                    response = requests.post(
                        f"{config.platform.base_url}/candidates/{candidate_id}/attachments",
                        headers={
                            "Authorization": f"Bearer {access_token}",
                        },
                        files={"file": file},
                        timeout=30,
                    )

        response.raise_for_status()
        print(f"Successfully uploaded CV for candidate {candidate_id}")
        return True

    except Exception as e:
        print(f"Error uploading CV to platform: {e}")
        return False


def has_cv_been_processed(attachment_id: str, organization_id: int) -> bool:
    """
    Check if CV has already been processed.
    """
    return FormattedCV.objects.filter(
        attachment_id=attachment_id, organization_id=organization_id
    ).exists()


def mark_cv_as_processed(
    attachment_id: str,
    organization_id: int,
    candidate_id: int,
    cv_data: Optional[Dict] = None,
    pdf_with_logo_path: Optional[str] = None,
    pdf_without_logo_path: Optional[str] = None,
) -> Optional[FormattedCV]:
    """
    Mark CV as processed in database and save PDF files.
    """
    try:
        formatted_cv = FormattedCV(
            attachment_id=attachment_id,
            organization_id=organization_id,
            candidate_id=candidate_id,
            extracted_data=cv_data or {},
            processed_at=datetime.now(timezone.utc),
        )

        # Save PDF files if provided
        if pdf_with_logo_path and os.path.exists(pdf_with_logo_path):
            with open(pdf_with_logo_path, "rb") as f:
                file_name = f"formatted_cv_with_logo_{attachment_id}.pdf"
                formatted_cv.pdf_file_with_logo.save(
                    file_name, ContentFile(f.read()), save=False
                )

        if pdf_without_logo_path and os.path.exists(pdf_without_logo_path):
            with open(pdf_without_logo_path, "rb") as f:
                file_name = f"formatted_cv_without_logo_{attachment_id}.pdf"
                formatted_cv.pdf_file_without_logo.save(
                    file_name, ContentFile(f.read()), save=False
                )

        formatted_cv.save()
        print(f"Successfully saved FormattedCV record for attachment {attachment_id}")
        return formatted_cv

    except Exception as e:
        print(f"Error marking CV as processed: {e}")
        import traceback

        traceback.print_exc()
        return None


@shared_task(max_retries=3)
def format_single_cv(
    attachment_id: str,
    candidate_id: int,
    candidate_name: str,
    attachment_url: str,
    file_name: str,
    organization_id: int,
):
    """
    Format a single CV for a candidate.
    """
    pdf_path_with_logo = None
    pdf_path_without_logo = None
    temp_file_path = None

    try:
        config = CVFormatterConfig.objects.get(organization_id=organization_id)
    except CVFormatterConfig.DoesNotExist:
        print(f"No CV formatter config found for organization {organization_id}")
        return

    # Check if already processed
    if has_cv_been_processed(attachment_id, organization_id):
        print(
            f"CV {attachment_id} already processed for organization {organization_id}"
        )
        return

    # Download CV file
    temp_file_path = f"resume_candidates/cv_{attachment_id}.pdf"

    try:
        # Download the file from platform
        access_token = config.platform.access_token
        response = requests.get(
            attachment_url,
            headers={"Authorization": f"Bearer {access_token}"},
            timeout=30,
        )

        if response.status_code == 401:
            access_token = config.platform.refresh_access_token()
            response = requests.get(
                attachment_url,
                headers={"Authorization": f"Bearer {access_token}"},
                timeout=30,
            )

        response.raise_for_status()

        with open(temp_file_path, "wb") as f:
            f.write(response.content)

        print(f"Downloaded CV for candidate: {candidate_name}")

    except Exception as e:
        print(f"Error downloading CV: {e}")
        return

    # Extract text from CV
    try:
        extracted_text = extract_text_from_pdf(temp_file_path)

        if not extracted_text:
            print(f"No text extracted from CV for {candidate_name}")
            if temp_file_path and os.path.exists(temp_file_path):
                os.remove(temp_file_path)
            return

    except Exception as e:
        print(f"Error extracting text: {e}")
        if temp_file_path and os.path.exists(temp_file_path):
            os.remove(temp_file_path)
        return

    # Process CV with OpenAI using function calling
    try:
        cv_data = extract_cv_data_with_openai(extracted_text)

        if not cv_data:
            print(f"Failed to extract CV data for {candidate_name}")
            if temp_file_path and os.path.exists(temp_file_path):
                os.remove(temp_file_path)
            return

        # Add logo URL to cv_data
        if config.logo:
            cv_data["logo"] = f"https://api.swiftwave.ai{config.logo.url}"

    except Exception as e:
        print(f"Error processing CV with AI: {e}")
        if temp_file_path and os.path.exists(temp_file_path):
            os.remove(temp_file_path)
        return

    # Generate formatted PDFs
    try:
        # With logo
        html_with_logo = render_cv_to_html(cv_data, with_logo=True)
        pdf_path_with_logo = f"{PDF_FOLDER}/formatted_{file_name}_{attachment_id}.pdf"

        if not convert_html_to_pdf(html_with_logo, pdf_path_with_logo):
            raise Exception("Failed to generate PDF with logo")

        # Without logo
        html_without_logo = render_cv_to_html(cv_data, with_logo=False)
        pdf_path_without_logo = (
            f"{PDF_FOLDER}/formatted_without_logo_{file_name}_{attachment_id}.pdf"
        )

        if not convert_html_to_pdf(html_without_logo, pdf_path_without_logo):
            raise Exception("Failed to generate PDF without logo")

        print(f"Generated formatted PDFs for {candidate_name}")

    except Exception as e:
        print(f"Error generating PDFs: {e}")
        # Cleanup
        if temp_file_path and os.path.exists(temp_file_path):
            os.remove(temp_file_path)
        if pdf_path_with_logo and os.path.exists(pdf_path_with_logo):
            os.remove(pdf_path_with_logo)
        if pdf_path_without_logo and os.path.exists(pdf_path_without_logo):
            os.remove(pdf_path_without_logo)
        return

    # Upload to platform (optional based on config)
    upload_success = True
    try:
        if config.upload_with_logo:
            upload_success = (
                upload_cv_to_platform(candidate_id, pdf_path_with_logo, config)
                and upload_success
            )
            time.sleep(5)

        if config.upload_without_logo:
            upload_success = (
                upload_cv_to_platform(candidate_id, pdf_path_without_logo, config)
                and upload_success
            )

        if upload_success:
            print(f"Successfully uploaded formatted CVs for {candidate_name}")

    except Exception as e:
        print(f"Error uploading CVs: {e}")
        upload_success = False

    # Save to database with PDF files
    try:
        formatted_cv = mark_cv_as_processed(
            attachment_id=attachment_id,
            organization_id=organization_id,
            candidate_id=candidate_id,
            cv_data=cv_data,
            pdf_with_logo_path=pdf_path_with_logo,
            pdf_without_logo_path=pdf_path_without_logo,
        )

        if formatted_cv:
            print(f"Successfully saved formatted CV to database for {candidate_name}")
        else:
            print(f"Failed to save formatted CV to database for {candidate_name}")

    except Exception as e:
        print(f"Error saving to database: {e}")

    # Cleanup temporary files
    finally:
        if temp_file_path and os.path.exists(temp_file_path):
            os.remove(temp_file_path)
        if pdf_path_with_logo and os.path.exists(pdf_path_with_logo):
            os.remove(pdf_path_with_logo)
        if pdf_path_without_logo and os.path.exists(pdf_path_without_logo):
            os.remove(pdf_path_without_logo)


@shared_task
def fetch_platform_cvs(config: "CVFormatterConfig") -> List[Dict]:
    """
    Fetch CVs from the recruitment platform that need formatting.
    """
    access_token = config.platform.access_token

    if not access_token:
        print("Error: Could not get platform access token")
        return []

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json",
    }

    cvs_to_process = []

    try:
        # Fetch live jobs
        jobs_response = requests.get(
            f"{config.platform.base_url}/jobads", headers=headers, timeout=30
        )

        if jobs_response.status_code == 401:
            access_token = config.platform.refresh_access_token()
            if access_token:
                headers["Authorization"] = f"Bearer {access_token}"
                jobs_response = requests.get(
                    f"{config.platform.base_url}/jobads", headers=headers, timeout=30
                )

        jobs_response.raise_for_status()
        jobs_data = jobs_response.json()

        print(
            f"Found {len(jobs_data.get('items', []))} jobs for organization {config.organization_id}"
        )

        for job in jobs_data.get("items", []):
            # Only process jobs in specified status
            if job.get("state") != config.job_status_for_formatting:
                continue

            job_title = job.get("title")
            applications_url = job.get("links", {}).get("applications")

            if not applications_url:
                continue

            try:
                # Fetch applications
                applications_response = requests.get(
                    applications_url, headers=headers, timeout=30
                )

                if applications_response.status_code == 401:
                    access_token = config.platform.refresh_access_token()
                    if access_token:
                        headers["Authorization"] = f"Bearer {access_token}"
                        applications_response = requests.get(
                            applications_url, headers=headers, timeout=30
                        )

                applications_response.raise_for_status()
                applications_data = applications_response.json()

                for application in applications_data.get("items", []):
                    candidate = application.get("candidate", {})
                    candidate_name = f"{candidate.get('firstName', '')} {candidate.get('lastName', '')}"

                    # Get the candidate's self URL
                    candidate_self_url = candidate.get("links", {}).get("self")

                    if not candidate_self_url:
                        print(f"No self URL found for candidate {candidate_name}")
                        continue

                    try:
                        # Fetch full candidate details
                        candidate_response = requests.get(
                            candidate_self_url, headers=headers, timeout=30
                        )

                        if candidate_response.status_code == 401:
                            access_token = config.platform.refresh_access_token()
                            if access_token:
                                headers["Authorization"] = f"Bearer {access_token}"
                                candidate_response = requests.get(
                                    candidate_self_url, headers=headers, timeout=30
                                )

                        candidate_response.raise_for_status()
                        candidate_data = candidate_response.json()

                        # Now get the attachments URL from the full candidate data
                        candidate_id = candidate_data.get("candidateId")
                        attachments_url = candidate_data.get("links", {}).get(
                            "attachments"
                        )

                        if not attachments_url:
                            print(
                                f"No attachments URL found for candidate {candidate_name}"
                            )
                            continue

                        # Fetch candidate attachments
                        attachments_response = requests.get(
                            attachments_url, headers=headers, timeout=30
                        )

                        if attachments_response.status_code == 401:
                            access_token = config.platform.refresh_access_token()
                            if access_token:
                                headers["Authorization"] = f"Bearer {access_token}"
                                attachments_response = requests.get(
                                    attachments_url, headers=headers, timeout=30
                                )

                        attachments_response.raise_for_status()
                        attachments_data = attachments_response.json()

                        for attachment in attachments_data.get("items", []):
                            # Only process resumes
                            if attachment.get("category") != "Resume":
                                continue

                            attachment_id = attachment.get("attachmentId")
                            file_name = attachment.get("fileName")
                            attachment_url = attachment.get("links", {}).get("self")

                            # Check if already processed
                            if has_cv_been_processed(
                                attachment_id, config.organization_id
                            ):
                                print(f"CV {attachment_id} already processed")
                                continue

                            cv_data = {
                                "attachment_id": attachment_id,
                                "candidate_id": candidate_id,
                                "candidate_name": candidate_name,
                                "attachment_url": attachment_url,
                                "file_name": file_name,
                                "organization_id": config.organization_id,
                            }

                            cvs_to_process.append(cv_data)
                            print(f"Added CV for processing: {candidate_name}")

                    except Exception as e:
                        print(
                            f"Error fetching candidate details or attachments for {candidate_name}: {e}"
                        )
                        continue

            except Exception as e:
                print(f"Error fetching applications for job {job_title}: {e}")
                continue

        print(f"Total CVs to process: {len(cvs_to_process)}")
        return cvs_to_process

    except Exception as e:
        print(f"Error fetching platform data: {e}")
        return []


@shared_task
def bulk_format_cvs(organization_id: int = None):
    """
    Bulk format CVs for a specific organization.
    """
    try:
        config = CVFormatterConfig.objects.get(organization_id=organization_id)
    except CVFormatterConfig.DoesNotExist:
        print(f"No CV formatter config found for organization {organization_id}")
        return

    cvs = fetch_platform_cvs(config)

    if not cvs:
        print(f"No CVs to process for organization {organization_id}")
        return

    # Queue CV formatting tasks with delays
    for i, cv in enumerate(cvs):
        countdown = i * 120  # 2 minutes delay between each task
        format_single_cv.apply_async(
            args=[
                cv["attachment_id"],
                cv["candidate_id"],
                cv["candidate_name"],
                cv["attachment_url"],
                cv["file_name"],
                cv["organization_id"],
            ],
            countdown=countdown,
        )

    print(f"Queued {len(cvs)} CVs for formatting for organization {organization_id}")


@shared_task
def initiate_all_cv_formatting():
    """
    Periodic task to format CVs for all organizations.
    """
    organization_ids = Organization.objects.filter().values_list("id", flat=True)

    subscribed_organization_ids = Subscription.objects.filter(
        organization_id__in=organization_ids, available_limit__gt=0
    ).values_list("organization_id", flat=True)

    for organization_id in subscribed_organization_ids:
        print(f"Initiating CV formatting for organization {organization_id}")
        bulk_format_cvs.delay(organization_id)
