import json
import os
from datetime import datetime, timezone
from typing import Dict, List, Optional

import requests
from celery import shared_task
from dotenv import load_dotenv
from openai import OpenAI

from cv_formatter.models import CVFormatterConfig, FormattedCV
from organizations.models import Organization
from subscription.models import Subscription

load_dotenv()

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
PDF_FOLDER = "formatted_pdfs"

# Ensure folders exist
os.makedirs(PDF_FOLDER, exist_ok=True)
os.makedirs("resume_candidates", exist_ok=True)


# Function tool definition
GET_CV_RETURN_TOOL = {
    "type": "function",
    "function": {
        "name": "get_cv_return",
        "description": (
            "You will return the formatted CV information to the user. "
            "You will execute this function to return the formatted CV information to the user. "
            "Now there are some instructions for you for some fields. "
            "The field professional_summary will be generated by you, you will generate by checking the CV "
            "and summarize the professional summary. "
            "The field skills will be generated by you, you will generate by checking the CV and summarize the skills. "
            "The field areas_of_expertise will be generated by you, you will generate by checking the CV and summarize the areas of expertise. "
            "The field areas_for_improvement will be generated by you, you will generate by checking the CV and summarize the areas for improvement."
        ),
        "parameters": {
            "type": "object",
            "strict": False,
            "required": [
                "full_name",
                "email_address",
                "phone_number",
                "address",
                "professional_summary",
                "professional_experience",
                "education",
                "skills",
                "certifications",
                "languages",
                "areas_of_expertise",
                "areas_for_improvement",
            ],
            "properties": {
                "full_name": {"type": ["string", "null"]},
                "email_address": {"type": ["string", "null"]},
                "phone_number": {"type": ["string", "null"]},
                "address": {"type": ["string", "null"]},
                "professional_summary": {"type": ["string", "null"]},
                "professional_experience": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": [
                            "job_title",
                            "company_name",
                            "start_date",
                            "end_date",
                            "position",
                            "job_description",
                        ],
                        "properties": {
                            "job_title": {"type": ["string", "null"]},
                            "company_name": {"type": ["string", "null"]},
                            "start_date": {"type": ["string", "null"]},
                            "end_date": {"type": ["string", "null"]},
                            "position": {"type": ["string", "null"]},
                            "job_description": {
                                "type": "array",
                                "items": {"type": "string"},
                            },
                        },
                    },
                },
                "education": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": [
                            "degree",
                            "major",
                            "school_name",
                            "start_date",
                            "end_date",
                        ],
                        "properties": {
                            "degree": {"type": ["string", "null"]},
                            "major": {"type": ["string", "null"]},
                            "school_name": {"type": ["string", "null"]},
                            "start_date": {"type": ["string", "null"]},
                            "end_date": {"type": ["string", "null"]},
                        },
                    },
                },
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["skill_name", "skill_description"],
                        "properties": {
                            "skill_name": {"type": ["string", "null"]},
                            "skill_description": {"type": ["string", "null"]},
                        },
                    },
                },
                "certifications": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": [
                            "certification_name",
                            "certification_authority",
                            "start_date",
                            "end_date",
                        ],
                        "properties": {
                            "certification_name": {"type": ["string", "null"]},
                            "certification_authority": {"type": ["string", "null"]},
                            "start_date": {
                                "type": ["string", "null"],
                                "format": "date",
                            },
                            "end_date": {"type": ["string", "null"], "format": "date"},
                        },
                    },
                },
                "languages": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["language_name", "proficiency"],
                        "properties": {
                            "language_name": {"type": ["string", "null"]},
                            "proficiency": {"type": ["string", "null"]},
                        },
                    },
                },
                "areas_of_expertise": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["expertise_name", "expertise_description"],
                        "properties": {
                            "expertise_name": {"type": ["string", "null"]},
                            "expertise_description": {"type": ["string", "null"]},
                        },
                    },
                },
                "areas_for_improvement": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["area_name", "area_description"],
                        "properties": {
                            "area_name": {"type": ["string", "null"]},
                            "area_description": {"type": ["string", "null"]},
                        },
                    },
                },
            },
        },
    },
}


def extract_text_from_pdf(file_path: str) -> Optional[str]:
    """
    Extract text from PDF using multiple fallback methods.
    """
    try:
        import fitz  # PyMuPDF

        doc = fitz.open(file_path)
        text = []
        for page in doc:
            text.append(page.get_text("text"))
        if text and "".join(text).strip():
            return "\n".join(text)
    except Exception as e:
        print(f"PyMuPDF failed: {e}")

    try:
        import pdfplumber

        with pdfplumber.open(file_path) as pdf:
            pages_text = [p.extract_text() or "" for p in pdf.pages]
        if any(pages_text):
            return "\n".join(pages_text)
    except Exception as e:
        print(f"pdfplumber failed: {e}")

    try:
        from pypdf import PdfReader

        reader = PdfReader(file_path)
        all_text = "\n".join(page.extract_text() or "" for page in reader.pages)
        return all_text.strip()
    except Exception as e:
        print(f"pypdf failed: {e}")

    try:
        import pytesseract
        from pdf2image import convert_from_path

        pages = convert_from_path(file_path, dpi=300)
        full_text = "\n".join(pytesseract.image_to_string(img) for img in pages)
        return full_text.strip()
    except Exception as e:
        print(f"OCR failed: {e}")

    return None


def extract_cv_data_with_openai(
    cv_text: str, sections: List[str] = None
) -> Optional[Dict]:
    """
    Extract CV data using OpenAI Chat Completions API with function calling.
    """
    try:
        client = OpenAI(api_key=OPENAI_API_KEY)

        prompt = f"""You are a professional CV parser and analyzer. Carefully read and analyze the following CV/resume text.

CV TEXT:
{cv_text}

IMPORTANT INSTRUCTIONS:
1. If this is not a professional CV/resume, return null values for all fields.
2. Extract all information accurately from the CV.
3. For the following fields, you must GENERATE intelligent summaries based on the CV content:
   - professional_summary: Write a compelling 2-3 sentence summary of the candidate's professional profile
   - skills: Extract and organize skills with meaningful descriptions
   - areas_of_expertise: Identify key areas where the candidate excels
   - areas_for_improvement: Suggest 2-3 constructive areas for professional development

4. For all other fields, extract the information exactly as it appears in the CV.
5. Use the get_cv_return function to return all the structured data.
"""

        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "system",
                    "content": "You are a professional CV parser and career advisor. Extract CV information accurately and provide insightful analysis.",
                },
                {"role": "user", "content": prompt},
            ],
            tools=[GET_CV_RETURN_TOOL],
            tool_choice={"type": "function", "function": {"name": "get_cv_return"}},
            temperature=0.3,
        )

        # Extract function call result
        message = response.choices[0].message

        if message.tool_calls:
            tool_call = message.tool_calls[0]
            if tool_call.function.name == "get_cv_return":
                result = json.loads(tool_call.function.arguments)

                # Validate that we got actual data
                if not result.get("full_name"):
                    print("No valid CV data extracted")
                    return None

                # Map the fields to match your template expectations
                mapped_result = {
                    "full_name": result.get("full_name"),
                    "email": result.get("email_address"),
                    "phone": result.get("phone_number"),
                    "address": result.get("address"),
                    "professional_summary": result.get("professional_summary"),
                    "professional_experience": result.get(
                        "professional_experience", []
                    ),
                    "education": result.get("education", []),
                    "skills": result.get("skills", []),
                    "certifications": result.get("certifications", []),
                    "languages": result.get("languages", []),
                    "areas_of_expertise": result.get("areas_of_expertise", []),
                    "recommendations": result.get(
                        "areas_for_improvement", []
                    ),  # Mapped to recommendations
                }

                return mapped_result

        print("No function call in response")
        return None

    except Exception as e:
        print(f"Error extracting CV data: {e}")
        import traceback

        traceback.print_exc()
        return None


def render_cv_to_html(cv_data: Dict, with_logo: bool = True) -> str:
    """
    Render CV data to HTML using Jinja2 template.
    """
    from jinja2 import Environment, FileSystemLoader

    env = Environment(loader=FileSystemLoader("templates"))

    if with_logo:
        template = env.get_template("cv_templates/cv_template.html")
    else:
        template = env.get_template("cv_templates/sec_cv_template.html")

    return template.render(cv_data=cv_data)


def convert_html_to_pdf(html_content: str, output_path: str) -> bool:
    """
    Convert HTML to PDF using WeasyPrint.
    """
    try:
        from weasyprint import CSS, HTML

        custom_css = """
        @page {
            margin: 0;
        }
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
        }
        .cv-container {
            margin: 0;
            padding: 0 40px 40px 40px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        """

        HTML(string=html_content).write_pdf(
            output_path, stylesheets=[CSS(string=custom_css)]
        )
        return True
    except Exception as e:
        print(f"Error converting HTML to PDF: {e}")
        return False


def upload_cv_to_platform(
    candidate_id: int, file_path: str, config: "CVFormatterConfig"
) -> bool:
    """
    Upload formatted CV to the recruitment platform.
    """
    try:
        access_token = config.platform.access_token

        response = requests.post(
            f"{config.platform.base_url}/candidates/{candidate_id}/attachments",
            headers={
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json",
            },
            files={"file": open(file_path, "rb")},
            timeout=30,
        )

        if response.status_code == 401:
            access_token = config.platform.refresh_access_token()
            if access_token:
                response = requests.post(
                    f"{config.platform.base_url}/candidates/{candidate_id}/attachments",
                    headers={
                        "Authorization": f"Bearer {access_token}",
                        "Content-Type": "application/json",
                    },
                    files={"file": open(file_path, "rb")},
                    timeout=30,
                )

        response.raise_for_status()
        print(f"Successfully uploaded CV for candidate {candidate_id}")
        return True

    except Exception as e:
        print(f"Error uploading CV to platform: {e}")
        return False


def has_cv_been_processed(attachment_id: str, organization_id: int) -> bool:
    """
    Check if CV has already been processed.
    """

    return FormattedCV.objects.filter(
        attachment_id=attachment_id, organization_id=organization_id
    ).exists()


def mark_cv_as_processed(
    attachment_id: str,
    organization_id: int,
    candidate_id: int,
    status: str,
    cv_data: Optional[Dict] = None,
):
    """
    Mark CV as processed in database.
    """

    FormattedCV.objects.create(
        attachment_id=attachment_id,
        organization_id=organization_id,
        candidate_id=candidate_id,
        status=status,
        extracted_data=cv_data or {},
        processed_at=datetime.now(timezone.utc),
    )


@shared_task(max_retries=3)
def format_single_cv(
    attachment_id: str,
    candidate_id: int,
    candidate_name: str,
    attachment_url: str,
    file_name: str,
    organization_id: int,
):
    """
    Format a single CV for a candidate.
    """
    try:
        config = CVFormatterConfig.objects.get(organization_id=organization_id)
    except CVFormatterConfig.DoesNotExist:
        print(f"No CV formatter config found for organization {organization_id}")
        return

    # Check if already processed
    if has_cv_been_processed(attachment_id, organization_id):
        print(
            f"CV {attachment_id} already processed for organization {organization_id}"
        )
        return

    # Download CV file
    temp_file_path = f"resume_candidates/cv_{attachment_id}.pdf"

    try:
        # Download the file from platform
        access_token = config.platform.access_token
        response = requests.get(
            attachment_url,
            headers={"Authorization": f"Bearer {access_token}"},
            timeout=30,
        )

        if response.status_code == 401:
            access_token = config.platform.refresh_access_token()
            response = requests.get(
                attachment_url,
                headers={"Authorization": f"Bearer {access_token}"},
                timeout=30,
            )

        response.raise_for_status()

        with open(temp_file_path, "wb") as f:
            f.write(response.content)

        print(f"Downloaded CV for candidate: {candidate_name}")

    except Exception as e:
        print(f"Error downloading CV: {e}")
        mark_cv_as_processed(
            attachment_id, organization_id, candidate_id, "download_failed"
        )
        return

    # Extract text from CV
    try:
        extracted_text = extract_text_from_pdf(temp_file_path)

        if not extracted_text:
            print(f"No text extracted from CV for {candidate_name}")
            mark_cv_as_processed(
                attachment_id, organization_id, candidate_id, "extraction_failed"
            )
            os.remove(temp_file_path)
            return

    except Exception as e:
        print(f"Error extracting text: {e}")
        mark_cv_as_processed(
            attachment_id, organization_id, candidate_id, "extraction_failed"
        )
        os.remove(temp_file_path)
        return

    # Process CV with OpenAI using function calling
    try:
        cv_data = extract_cv_data_with_openai(extracted_text)

        if not cv_data:
            print(f"Failed to extract CV data for {candidate_name}")
            mark_cv_as_processed(
                attachment_id, organization_id, candidate_id, "parsing_failed"
            )
            os.remove(temp_file_path)
            return
        cv_data["logo"] = config.logo

    except Exception as e:
        print(f"Error processing CV with AI: {e}")
        mark_cv_as_processed(attachment_id, organization_id, candidate_id, "ai_failed")
        os.remove(temp_file_path)
        return

    # Generate formatted PDFs
    try:
        # With logo
        html_with_logo = render_cv_to_html(cv_data, with_logo=True)
        pdf_path_with_logo = f"{PDF_FOLDER}/formatted_{file_name}_{attachment_id}.pdf"

        if not convert_html_to_pdf(html_with_logo, pdf_path_with_logo):
            raise Exception("Failed to generate PDF with logo")

        # Without logo
        html_without_logo = render_cv_to_html(cv_data, with_logo=False)
        pdf_path_without_logo = (
            f"{PDF_FOLDER}/formatted_without_logo_{file_name}_{attachment_id}.pdf"
        )

        if not convert_html_to_pdf(html_without_logo, pdf_path_without_logo):
            raise Exception("Failed to generate PDF without logo")

        print(f"Generated formatted PDFs for {candidate_name}")

    except Exception as e:
        print(f"Error generating PDFs: {e}")
        mark_cv_as_processed(
            attachment_id, organization_id, candidate_id, "pdf_generation_failed"
        )
        os.remove(temp_file_path)
        return

    # Upload to platform
    try:
        # if config.upload_with_logo:
        #     upload_cv_to_platform(candidate_id, pdf_path_with_logo, config)
        #     time.sleep(5)

        # if config.upload_without_logo:
        #     upload_cv_to_platform(candidate_id, pdf_path_without_logo, config)
        print(f"Successfully uploaded formatted CVs for {candidate_name}")

        # Mark as successfully processed
        mark_cv_as_processed(
            attachment_id, organization_id, candidate_id, "success", cv_data
        )

        # Cleanup
        os.remove(temp_file_path)
        if os.path.exists(pdf_path_with_logo):
            os.remove(pdf_path_with_logo)
        if os.path.exists(pdf_path_without_logo):
            os.remove(pdf_path_without_logo)

    except Exception as e:
        print(f"Error uploading CVs: {e}")
        mark_cv_as_processed(
            attachment_id, organization_id, candidate_id, "upload_failed", cv_data
        )
        # Still cleanup files
        os.remove(temp_file_path)
        if os.path.exists(pdf_path_with_logo):
            os.remove(pdf_path_with_logo)
        if os.path.exists(pdf_path_without_logo):
            os.remove(pdf_path_without_logo)


@shared_task
def fetch_platform_cvs(config: "CVFormatterConfig") -> List[Dict]:
    """
    Fetch CVs from the recruitment platform that need formatting.
    """
    access_token = config.platform.access_token

    if not access_token:
        print("Error: Could not get platform access token")
        return []

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json",
    }

    cvs_to_process = []

    try:
        # Fetch live jobs
        jobs_response = requests.get(
            f"{config.platform.base_url}/jobads", headers=headers, timeout=30
        )

        if jobs_response.status_code == 401:
            access_token = config.platform.refresh_access_token()
            if access_token:
                headers["Authorization"] = f"Bearer {access_token}"
                jobs_response = requests.get(
                    f"{config.platform.base_url}/jobads", headers=headers, timeout=30
                )

        jobs_response.raise_for_status()
        jobs_data = jobs_response.json()

        print(
            f"Found {len(jobs_data.get('items', []))} jobs for organization {config.organization_id}"
        )

        for job in jobs_data.get("items", []):
            # Only process jobs in specified status
            if job.get("state") != config.job_status_for_formatting:
                continue

            job_title = job.get("title")
            applications_url = job.get("links", {}).get("applications")

            if not applications_url:
                continue

            try:
                # Fetch applications
                applications_response = requests.get(
                    applications_url, headers=headers, timeout=30
                )

                if applications_response.status_code == 401:
                    access_token = config.platform.refresh_access_token()
                    if access_token:
                        headers["Authorization"] = f"Bearer {access_token}"
                        applications_response = requests.get(
                            applications_url, headers=headers, timeout=30
                        )

                applications_response.raise_for_status()
                applications_data = applications_response.json()

                for application in applications_data.get("items", []):
                    candidate = application.get("candidate", {})
                    candidate_name = f"{candidate.get('firstName', '')} {candidate.get('lastName', '')}"

                    # Get the candidate's self URL
                    candidate_self_url = candidate.get("links", {}).get("self")

                    if not candidate_self_url:
                        print(f"No self URL found for candidate {candidate_name}")
                        continue

                    try:
                        # Fetch full candidate details
                        candidate_response = requests.get(
                            candidate_self_url, headers=headers, timeout=30
                        )

                        if candidate_response.status_code == 401:
                            access_token = config.platform.refresh_access_token()
                            if access_token:
                                headers["Authorization"] = f"Bearer {access_token}"
                                candidate_response = requests.get(
                                    candidate_self_url, headers=headers, timeout=30
                                )

                        candidate_response.raise_for_status()
                        candidate_data = candidate_response.json()

                        # Now get the attachments URL from the full candidate data
                        candidate_id = candidate_data.get("candidateId")
                        attachments_url = candidate_data.get("links", {}).get(
                            "attachments"
                        )

                        if not attachments_url:
                            print(
                                f"No attachments URL found for candidate {candidate_name}"
                            )
                            continue

                        # Fetch candidate attachments
                        attachments_response = requests.get(
                            attachments_url, headers=headers, timeout=30
                        )

                        if attachments_response.status_code == 401:
                            access_token = config.platform.refresh_access_token()
                            if access_token:
                                headers["Authorization"] = f"Bearer {access_token}"
                                attachments_response = requests.get(
                                    attachments_url, headers=headers, timeout=30
                                )

                        attachments_response.raise_for_status()
                        attachments_data = attachments_response.json()

                        for attachment in attachments_data.get("items", []):
                            # Only process resumes
                            if attachment.get("category") != "Resume":
                                continue

                            attachment_id = attachment.get("attachmentId")
                            file_name = attachment.get("fileName")
                            attachment_url = attachment.get("links", {}).get("self")

                            # Check if already processed
                            if has_cv_been_processed(
                                attachment_id, config.organization_id
                            ):
                                print(f"CV {attachment_id} already processed")
                                continue

                            cv_data = {
                                "attachment_id": attachment_id,
                                "candidate_id": candidate_id,
                                "candidate_name": candidate_name,
                                "attachment_url": attachment_url,
                                "file_name": file_name,
                                "organization_id": config.organization_id,
                            }

                            cvs_to_process.append(cv_data)
                            print(f"Added CV for processing: {candidate_name}")

                    except Exception as e:
                        print(
                            f"Error fetching candidate details or attachments for {candidate_name}: {e}"
                        )
                        continue

            except Exception as e:
                print(f"Error fetching applications for job {job_title}: {e}")
                continue

        print(f"Total CVs to process: {len(cvs_to_process)}")
        return cvs_to_process

    except Exception as e:
        print(f"Error fetching platform data: {e}")
        return []


@shared_task
def bulk_format_cvs(organization_id: int = None):
    try:
        config = CVFormatterConfig.objects.get(organization_id=organization_id)
    except CVFormatterConfig.DoesNotExist:
        print(f"No CV formatter config found for organization {organization_id}")
        return

    cvs = fetch_platform_cvs(config)

    if not cvs:
        print(f"No CVs to process for organization {organization_id}")
        return

    # Queue CV formatting tasks with delays
    for i, cv in enumerate(cvs):
        countdown = i * 120
        format_single_cv.apply_async(
            args=[
                cv["attachment_id"],
                cv["candidate_id"],
                cv["candidate_name"],
                cv["attachment_url"],
                cv["file_name"],
                cv["organization_id"],
            ],
            countdown=countdown,
        )

    print(f"Queued {len(cvs)} CVs for formatting for organization {organization_id}")


@shared_task
def initiate_all_cv_formatting():
    """
    Periodic task to format CVs for all organizations.
    """
    organization_ids = Organization.objects.filter().values_list("id", flat=True)

    subscribed_organization_ids = Subscription.objects.filter(
        organization_id__in=organization_ids, available_limit__gt=0
    ).values_list("organization_id", flat=True)

    for organization_id in subscribed_organization_ids:
        print(f"Initiating CV formatting for organization {organization_id}")
        bulk_format_cvs.delay(organization_id)
